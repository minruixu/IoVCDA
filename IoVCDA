# Mobile Quantum Computing
from asyncio import tasks
import functools
import os
from re import I
# from symbol import dotted_as_names
import numpy as np
import math
import cmath
import scipy.special as sc
import matplotlib.pyplot as plt
import pandas as pd
import gym
import math
from numpy import random
from functools import partial
from typing import Tuple, Optional
from pettingzoo import ParallelEnv
import warnings
from typing import Any, Dict, Iterable, Iterator, List, Optional, Tuple, TypeVar
from scipy import constants
from scipy import integrate
import gym.spaces
import numpy as np
from orderbook import OrderBook

ObsType = TypeVar("ObsType")
ActionType = TypeVar("ActionType")
AgentID = str
ObsDict = Dict[AgentID, ObsType]
ActionDict = Dict[AgentID, ActionType]
from numpy.core.fromnumeric import sort
path1 = os.path.abspath(".")



class IoVCDA(gym.Env, ParallelEnv):
    """
        This is a simple implementation of coutinuous double auction in Internet of Vehicles

        Workflow:
            1. 首先初始化车联网中的车辆和RSU, 我们考虑: RSU的通信资源大于车辆所需的通信资源, 但是每辆车只拥有预留在RSU处的带宽资源
            2. 根据RSU的覆盖范围, 每个RSU初始化他们自己的本地市场.
            3. 在这个本地市场中, 想要购买视频的车辆成为买家, 而没有需求的车辆成为买家, 那么这时候买家就可以向卖家出售贷款资源
            4. 买家和卖家都确定了, 然后买家通过观察他们周围的情况, 输出他们的aggressiveness,表示进入什么市场
            5. 不同市场有不同的清算机制,
                primary market: （与最近的提供者进行交易) 1 v 1 市场, 就是一价拍卖, 这种拍卖方式 可以保证 IR, 但不能保证 IC 和 BB
                Note: 为什么说车辆在primary market不是是IR的，因为无论车辆的出价是多少，收到的商品 （信道资源）都是最好的，所以他改变他的出价并不能改变他的utility = value - cost
                    为什么他是IR的，如果他的出价低于买家索要的要价时，可以通过平台提供的补助满足他的IR

                recovery market: 1 v n 市场, 使用二价拍卖, 这种拍卖方式 可以保证 IR, IC, 但 BB 不确定
                ordinary market: n v n 市场, 使用 Macfee的清算方式, 这种清算方式可以保证IR, IC, 且 BB 大于 0
                问题的关键是：如果一个市场
            6。 然后各个市场进行市场清算
            7. 对市场清算的结果计算当前总市场

            Note: 这个环境的优化变量是车辆在不同轮次，不同位置选择进入不同的市场，从而根据不同市场的清算规则，计算市场中的IR和IC

            实验需要验证的内容: 
            1. 所提出算法再不同场景下的收敛性
            2. 性能对比, 在不同用户数量的情况下


    """

    def __init__(self):
        super().__init__()
        random.seed(131) # 88888
        self.rounds = 10
        self.RSUs = 3 # number of submarket
        self.vehicles = 10 # total number of vehicles

        # self.required_quality = random.randint(0, self.rounds, self.vehicles)
        # required quality 根据时间变化吧

        self.required_quality = random.randint(0, 2, (self.rounds, self.vehicles))
        
        self.values = random.uniform(0,1, self.vehicles)
        self.values[::-1].sort()
        print(self.values)

        self.location = random.randint(0, self.RSUs, (self.rounds, self.vehicles))


        self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(1,), dtype=np.float32)
        # the auction space is three, indicating their aggresiveness
        self.action_space = gym.spaces.Discrete(3) # 



    def reset(self, seed=None) -> np.ndarray: # 这个reset还能改seed, 太牛了
        # 初始化用户的任务和云的负载
        self.num_moves = 0 # 需要经过 N 轮的轮换

        self.budget = 0

        # self.expected_quality = self.required_quality[self.num_moves]

        self.total_satisfied = np.zeros(self.vehicles)

        observations = []
        for i in range(self.vehicles):
            observations.append(np.concatenate(([],[])))
        observations = np.array(observations)
        # print(observations.shape)
        # observations =[[]
        #         for i in range(len(self.agents))]
        # print(type(observations))
        # observations = {agent: None for agent in self.agents}
        self._observations = observations
        self._rew = []
        self._done = []
        return observations
    def make_order(self, side, quantity, price, trade_id):
        order = {'type' : 'limit', 
                 'side' : side, 
                 'quantity' : quantity, 
                 'price' : price,
                 'trade_id' : trade_id}
        return order

    def step(self, actions: np.ndarray
             ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, dict]:

        # check seller and buyer
        self.current_budget = 0
        self.current_volumn = []
        self.current_price = []
        self.sellers = []
        self.buyers = []
        
        # compute global ce price:
        global_sell_ask = []
        global_buy_bid = []

        # 买家是主动的, 卖家是被动的
        # for each local market:
        for i in range(self.RSUs):
            self.local_volume = 0
            self.local_revenue = 0
            self.local_budget = 0
            # 首先构建这一个market的seller pool
            # local_first_buyerbook = OrderBook()
            # local_second_buyerbook = OrderBook()
            # local_third_buyerbook = OrderBook()
            # for sellers
            local_sell_value = []
            for j in range(self.vehicles):
                if self.expected_quality[j] == 0:
                    local_sell_value.append[self.values[j]]
            local_buy_value = []
            for j in range(self.vehicles):
        # primary market:
                if self.location[j] == i and actions[j] == 0:
                    # FIFO
                    if len(local_sell_value) >= 0:
                        self.local_volume += 1
                        self.local_revenue += local_sell_value[-1]
                        self.local_budget += self.values[j] - local_sell_value[-1]
                        local_sell_value.pop(-1)
                    # trade with the first sellers
                    # trades, order_id, trader_id = local_first_buyerbook.process_order(self.make_order("bid", self.expected_quality[j], self.values[j],j),False, False)
        # recovery market:
                if self.location[j] == i and actions[j] == 1:
                    # Second Auction
                    if len(local_sell_value) >= 2:
                        self.local_volume += 1
                        self.local_revenue += local_sell_value[-2]
                        self.local_budget += self.values[j] - local_sell_value[-2]
                        local_sell_value.pop(-1)
        # ordinary market:
                if self.location[j] == i and actions[j] == 2:
                    local_buy_value.append()
            # clear local market
            len_buyer = len(local_buy_value)
            len_seller = len(local_sell_value)
            k = 0
            while local_buy_value[k] >= local_sell_value[k] and k < len_buyer and k < len_seller:
                k += 1
            if k == len_buyer:
                p_buyer = local_buy_value[-1]
            else:
                p_buyer = local_buy_value[k]
            if k == len_seller:
                p_seller = local_sell_value[-1]
            else:
                p_seller = local_sell_value[k]
            # check clear rule
            if k == 0:
                self.local_volume += 0
            elif (p_buyer+p_seller)/2 >= local_sell_value[k-1] and (p_buyer+p_seller)/2 <= local_buy_value[k-1]:
                self.local_volume += k-1
                self.local_revenue 
            else:
                self.local_volume += k-2
                    
        rewards =  0
        # print(total_latency, total_energy)
        self.num_moves += 1
        if self.num_moves > self.rounds:
            dones = [True for agent in self.agents]
        else:
            # self.expected_quality += self.required_quality[self.num_moves]
            dones = [False for agent in self.agents]

        # current observation is just the other player's most recent action
        observations = []
        for i in range(self.user_n):
            observations.append(np.concatenate(([],[])))
        observations = np.array(observations)

        # typically there won't be any information in the infos, but there must
        # still be an entry for each agent
        infos = {}

        return observations, rewards, dones, infos

    def seed(self, seed: Optional[int] = None) -> int:
        pass

    def observe(self, agent):
        observation = 0
        # observation = pygame.surfarray.pixels3d(self.screen)
        # i = self.agent_name_mapping[agent]
        # # Set x bounds to include 40px left and 40px right of piston
        # x_high = self.wall_width + self.piston_width * (i + 2)
        # x_low = self.wall_width + self.piston_width * (i - 1)
        # y_high = self.screen_height - self.wall_width - self.piston_body_height
        # y_low = self.wall_width
        # cropped = np.array(observation[x_low:x_high, y_low:y_high, :])
        # observation = np.rot90(cropped, k=3)
        # observation = np.fliplr(observation)
        return observation
    def state(self):
        """Returns an observation of the global environment."""
        state = 0
        # state = pygame.surfarray.pixels3d(self.screen).copy()
        # state = np.rot90(state, k=3)
        # state = np.fliplr(state)
        return state
    def test_random(self):
        total_r = []
        for i in range(100):
            self.reset()
            ac_allocation = np.random.randint(0,10,(self.user_n,))
            ac_partial = np.random.uniform(0,1,(self.user_n,))
            acs = []
            # make action
            for i in range(self.user_n):
                acs.append(ac_allocation[i])
                acs.append(ac_partial[i])
            acs = np.array(acs)
            s, r, d, i = env.step(acs)
            total_r.append(r[0])
        return np.array(total_r).mean()
    def test_random_cloud(self):
        total_r = []
        for i in range(100):
            self.reset()
            ac_allocation = np.random.randint(0,10,(self.user_n,))
            ac_partial = np.zeros(self.user_n)
            acs = []
            # make action
            for i in range(self.user_n):
                acs.append(ac_allocation[i])
                acs.append(ac_partial[i])
            acs = np.array(acs)
            s, r, d, i = env.step(acs)
            total_r.append(r[0])
        return np.array(total_r).mean()

    def test_greedy_cloud(self):
        total_r = []
        for i in range(100):
            self.reset()
            idx = np.argsort(self.server_qubits)[::-1]
            # print(self.server_qubits)
            # print(idx)
            ac_allocation = np.arange(self.user_n)
            # print("+")
            ac_allocation = ac_allocation[idx]
            # print(ac_allocation)
            ac_partial = np.zeros(self.user_n)
            acs = []
            # make action
            for i in range(self.user_n):
                acs.append(ac_allocation[i])
                acs.append(ac_partial[i])
            acs = np.array(acs)
            s, r, d, i = env.step(acs)
            total_r.append(r[0])
        return np.array(total_r).mean()

    def test_local(self):
        total_r = []
        for i in range(100):
            self.reset()
            ac_allocation = np.random.randint(0,10,(self.user_n,))
            ac_partial = np.ones(self.user_n)
            acs = []
            # make action
            for i in range(self.user_n):
                acs.append(ac_allocation[i])
                acs.append(ac_partial[i])
            acs = np.array(acs)
            # print(acs)
            s, r, d, i = env.step(acs)
            total_r.append(r[0])
        return np.array(total_r).mean()
    def close(self) -> None:
        pass

if __name__ == "__main__":
    env = IoVCDA()
